
Things to ask Alex:

how to : 
  deal with the clump of data points surrounding a specific x point
  allow the user to change the range of y axis (zoom in on a certain depth interval for example) 
  

ToDo:

Enable selection of start node as well as end node

Add path nodes to the paths in bottom plot (done)

Add connecting red lines to incoming branches (as well as outgoing) 

Mouseover any part of the path to see equivalent lat/lon spot

Add depth to the data, thus enabling a depth dependent time series of data in bottom plot (done) 

order plots according to their position in relation to the main branch  (done) 

what determines the domain of each subaxis in bottom plot? max/min of all data? (problem, scale is already compressed, including all points further comresses scale. 

problem with having each ydomain be different it that it hinders comparison between branches



Deal with cycles

delete node / add node


Bugs:

merging paths





questions

1) how to ensure user selects end node after start node

2) how to select start/end node (double click for end node) 


  next steps:
  
  things you cannot do (break apart nodes, delete nodes, add node along the path) 
   
  todo
  
  force avoid cycles
  
 how to set minimum distance for "merge nodes"
 
 what is the criteria for "breaking apart a branching point (multiple outgoing or incoming) 
 
 what is the criteria for deleting a node? 
 
 stack size is exceeded when we create cycles
 
 stack size is exceeded if you try to merge two nodes of the same branch (in has_node) 
 
 

 
 connect when incoming branches join (as well as outgoing ) red dashed line
 
 Major questions:
 
 how to determine order in y axis? 
 
 best way of showing data in subplot (sparse data) 
 
 /*
.on("mouseover", function() {
	                        xx = x.invert(d3.mouse(this)[0]);
	                        yy = Math.round(y.invert(d3.mouse(this)[1]));
	                        d3.select('#b_' + yy).classed("highlighted", true);
	                        d3.select('#t_' + yy).classed("highlighted", true);
	
	                    })
	                    .on("mouseout", function() {
	                        xx = x.invert(d3.mouse(this)[0]);
	                        yy = Math.round(y.invert(d3.mouse(this)[1]));
	                        d3.select('#b_' + yy).classed("highlighted", false);
	                        d3.select('#t_' + yy).classed("highlighted", false);
	                    })
*/
 
 
 
 user_data.push({
	            "lon": d,
	            "lat": data.lat[i],
	            "value": data.temp[i],
	            "depth": 0,
	            "level": 0, //for depth dependent data, this would be another col of data. 
	            "dist2path": 0, //distance to the closest path
	            "distalongpath": -1, //distance along path the projection of this point falls
	            "branch": -1, //indicates which branch this data point falls on;
	            "selected": false //flag for data points on a path
	        })

	        user_data.push({
	            "lon": d,
	            "lat": data.lat[i],
	            "value": data.temp[i] * 0.7,
	            "depth": 20,
	            "level": 0, //for depth dependent data, this would be another col of data. 
	            "dist2path": 0, //distance to the closest path
	            "distalongpath": -1, //distance along path the projection of this point falls
	            "branch": -1, //indicates which branch this data point falls on;
	            "selected": false //flag for data points on a path
	        })

	        user_data.push({
	            "lon": d,
	            "lat": data.lat[i],
	            "value": data.temp[i] * 0.5,
	            "depth": 40,
	            "level": 0, //for depth dependent data, this would be another col of data. 
	            "dist2path": 0, //distance to the closest path
	            "distalongpath": -1, //distance along path the projection of this point falls
	            "branch": -1, //indicates which branch this data point falls on;
	            "selected": false //flag for data points on a path
	        })

	        user_data.push({
	            "lon": d,
	            "lat": data.lat[i],
	            "value": data.temp[i] * 0.9,
	            "depth": 60,
	            "level": 0, //for depth dependent data, this would be another col of data. 
	            "dist2path": 0, //distance to the closest path
	            "distalongpath": -1, //distance along path the projection of this point falls
	            "branch": -1, //indicates which branch this data point falls on;
	            "selected": false //flag for data points on a path
	        })

	        user_data.push({
	            "lon": d,
	            "lat": data.lat[i],
	            "value": data.temp[i] * 0.3,
	            "depth": 80,
	            "level": 0, //for depth dependent data, this would be another col of data. 
	            "dist2path": 0, //distance to the closest path
	            "distalongpath": -1, //distance along path the projection of this point falls
	            "branch": -1, //indicates which branch this data point falls on;
	            "selected": false //flag for data points on a path
	        })

	        user_data.push({
	            "lon": d,
	            "lat": data.lat[i],
	            "value": data.temp[i] * 0.2,
	            "depth": 100,
	            "level": 0, //for depth dependent data, this would be another col of data. 
	            "dist2path": 0, //distance to the closest path
	            "distalongpath": -1, //distance along path the projection of this point falls
	            "branch": -1, //indicates which branch this data point falls on;
	            "selected": false //flag for data points on a path
	        })


 
 
 
  